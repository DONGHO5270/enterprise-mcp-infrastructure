"use strict";
// ============================================================================
// Phase 2: ÏòàÏ∏° Î∂ÑÏÑù ÏãúÏä§ÌÖú - Ïã§Ï†ú ML Íµ¨ÌòÑ
// ============================================================================
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PredictiveAnalyzer = void 0;
const events_1 = require("events");
const tf = __importStar(require("@tensorflow/tfjs-node"));
const ss = __importStar(require("simple-statistics"));
const ml_regression_1 = __importDefault(require("ml-regression"));
const moving_averages_1 = require("moving-averages");
const logger_1 = require("../utils/logger");
class PredictiveAnalyzer extends events_1.EventEmitter {
    predictiveConfig;
    historicalData = new Map();
    models = new Map();
    anomalyThresholds = new Map();
    MAX_HISTORY_SIZE = 10000; // ÏµúÎåÄ ÌûàÏä§ÌÜ†Î¶¨ ÌÅ¨Í∏∞
    ANOMALY_Z_SCORE_THRESHOLD = 2.5; // Z-score ÏûÑÍ≥ÑÍ∞í
    constructor(config) {
        super();
        this.predictiveConfig = config;
        this.initialize();
    }
    initialize() {
        if (!this.predictiveConfig.enabled) {
            logger_1.logger.warn('[PHASE-2] PredictiveAnalyzer is disabled - real implementation ready');
            return;
        }
        logger_1.logger.info('ü§ñ Initializing PredictiveAnalyzer with ML capabilities');
        // TensorFlow Ï¥àÍ∏∞Ìôî
        tf.ready().then(() => {
            logger_1.logger.info('‚úÖ TensorFlow.js initialized successfully');
        });
    }
    // ============================================================================
    // Í≥µÍ∞ú Î©îÏÑúÎìú
    // ============================================================================
    async analyze(serviceId, metrics) {
        if (!this.predictiveConfig.enabled) {
            return this.generateSkeletonPrediction(serviceId);
        }
        try {
            // ÌûàÏä§ÌÜ†Î¶¨Ïóê Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
            this.addToHistory(serviceId, metrics);
            // Ïã§Ï†ú ÏòàÏ∏° Î∂ÑÏÑù ÏàòÌñâ
            const predictions = await this.generateRealPrediction(serviceId);
            const anomalies = this.performAnomalyDetection(serviceId, metrics);
            const trends = this.analyzeTrends(serviceId);
            const patterns = this.recognizePatterns(serviceId);
            const result = {
                serviceId,
                predictions,
                trends,
                patterns
            };
            // Ïù¥ÏÉÅ ÌÉêÏßÄ Í≤∞Í≥ºÍ∞Ä ÏûàÏúºÎ©¥ Ïù¥Î≤§Ìä∏ Î∞úÏÉù
            if (anomalies.anomalies.length > 0) {
                this.emit('anomaly-detected', anomalies);
            }
            return result;
        }
        catch (error) {
            logger_1.logger.error(`[PHASE-2] Prediction analysis failed for ${serviceId}:`, error);
            return this.generateSkeletonPrediction(serviceId);
        }
    }
    // ============================================================================
    // Ïã§Ï†ú ML Íµ¨ÌòÑ Î©îÏÑúÎìú
    // ============================================================================
    async generateRealPrediction(serviceId) {
        const history = this.historicalData.get(serviceId) || [];
        if (history.length < 10) {
            // Îç∞Ïù¥ÌÑ∞Í∞Ä Ï∂©Î∂ÑÌïòÏßÄ ÏïäÏúºÎ©¥ Í∞ÑÎã®Ìïú ÌÜµÍ≥Ñ Í∏∞Î∞ò ÏòàÏ∏°
            return this.generateStatisticalPrediction(serviceId, history);
        }
        // LSTM Î™®Îç∏Ïù¥ ÏóÜÏúºÎ©¥ ÏÉùÏÑ±
        if (!this.models.has(serviceId)) {
            await this.createLSTMModel(serviceId);
        }
        // ÏãúÍ≥ÑÏó¥ ÏòàÏ∏° ÏàòÌñâ
        const forecast = await this.performTimeSeriesForecast(serviceId, history);
        // Í∂åÏû• ÏÇ¨Ìï≠ ÏÉùÏÑ±
        const recommendations = this.generateIntelligentRecommendations(serviceId, forecast, history);
        return {
            nextHourLoad: forecast.nextHourLoad,
            anomalyProbability: forecast.anomalyProbability,
            recommendedActions: recommendations,
            confidence: forecast.confidence,
            forecast: forecast.details
        };
    }
    async createLSTMModel(serviceId) {
        const model = tf.sequential({
            layers: [
                tf.layers.lstm({
                    units: 50,
                    returnSequences: true,
                    inputShape: [10, 1] // 10 timesteps, 1 feature
                }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.lstm({
                    units: 50,
                    returnSequences: false
                }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.dense({ units: 25 }),
                tf.layers.dense({ units: 1 })
            ]
        });
        model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'meanSquaredError',
            metrics: ['mae']
        });
        this.models.set(serviceId, model);
        logger_1.logger.info(`‚úÖ LSTM model created for service: ${serviceId}`);
    }
    async performTimeSeriesForecast(serviceId, history) {
        const model = this.models.get(serviceId);
        if (!model || history.length < 10) {
            return this.generateStatisticalPrediction(serviceId, history);
        }
        try {
            // Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
            const values = history.slice(-100).map(h => h.metrics.avgResponseTime || 0);
            const normalized = this.normalizeData(values);
            // ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (sliding window)
            const windowSize = 10;
            const X = [];
            for (let i = 0; i < normalized.length - windowSize; i++) {
                X.push(normalized.slice(i, i + windowSize));
            }
            if (X.length === 0) {
                return this.generateStatisticalPrediction(serviceId, history);
            }
            // ÏòàÏ∏° ÏàòÌñâ
            const input = tf.tensor3d([X[X.length - 1].map(v => [v])], [1, windowSize, 1]);
            const prediction = model.predict(input);
            const predictedValue = await prediction.data();
            // Ï†ïÍ∑úÌôî Ìï¥Ï†ú
            const denormalized = this.denormalizeValue(predictedValue[0], Math.min(...values), Math.max(...values));
            // Ïã†Î¢∞ÎèÑ Í≥ÑÏÇ∞
            const mape = this.calculateMAPE(values.slice(-20), X.slice(-20).map(x => x[x.length - 1]));
            const confidence = Math.max(0.5, Math.min(0.95, 1 - mape / 100));
            // Ïù¥ÏÉÅ ÌôïÎ•† Í≥ÑÏÇ∞
            const zScore = Math.abs((denormalized - ss.mean(values)) / ss.standardDeviation(values));
            const anomalyProbability = Math.min(1, zScore / 3);
            // Ï†ïÎ¶¨
            input.dispose();
            prediction.dispose();
            return {
                nextHourLoad: denormalized,
                anomalyProbability,
                confidence,
                details: {
                    method: 'LSTM',
                    trainingSamples: X.length,
                    mape: mape.toFixed(2) + '%'
                }
            };
        }
        catch (error) {
            logger_1.logger.error(`LSTM prediction failed for ${serviceId}:`, error);
            return this.generateStatisticalPrediction(serviceId, history);
        }
    }
    generateStatisticalPrediction(serviceId, history) {
        if (history.length === 0) {
            return {
                nextHourLoad: 50,
                anomalyProbability: 0,
                recommendedActions: ['Insufficient data for prediction'],
                confidence: 0.1
            };
        }
        const values = history.map(h => h.metrics.avgResponseTime || 0);
        // Ïù¥Îèô ÌèâÍ∑† Í≥ÑÏÇ∞
        const ma7 = (0, moving_averages_1.sma)(values, 7);
        const ema7 = (0, moving_averages_1.ema)(values, 7);
        // ÏÑ†Ìòï ÌöåÍ∑Ä
        const x = Array.from({ length: values.length }, (_, i) => i);
        const regression = new ml_regression_1.default.SimpleLinearRegression(x, values);
        const nextValue = regression.predict(values.length);
        // Í≥ÑÏ†àÏÑ± Í≤ÄÏ∂ú
        const seasonality = this.detectSeasonality(values);
        // ÏòàÏ∏°Í∞í Í≤∞Ìï© (Í∞ÄÏ§ë ÌèâÍ∑†)
        const weights = { ma: 0.3, ema: 0.3, regression: 0.2, seasonal: 0.2 };
        const prediction = (ma7[ma7.length - 1] || 0) * weights.ma +
            (ema7[ema7.length - 1] || 0) * weights.ema +
            nextValue * weights.regression +
            (seasonality.nextValue || values[values.length - 1]) * weights.seasonal;
        // Ïù¥ÏÉÅ ÌôïÎ•†
        const mean = ss.mean(values);
        const std = ss.standardDeviation(values);
        const zScore = Math.abs((prediction - mean) / std);
        const anomalyProbability = Math.min(1, zScore / 3);
        return {
            nextHourLoad: Math.max(0, Math.min(100, prediction)),
            anomalyProbability,
            recommendedActions: this.generateStatisticalRecommendations(prediction, mean, std),
            confidence: Math.min(0.8, 0.3 + (history.length / 100) * 0.5),
            details: {
                method: 'Statistical',
                samples: values.length,
                trend: regression.slope > 0 ? 'increasing' : 'decreasing'
            }
        };
    }
    performAnomalyDetection(serviceId, currentMetrics) {
        const history = this.historicalData.get(serviceId) || [];
        const anomalies = [];
        if (history.length < 20) {
            return { serviceId, anomalies, lastAnalysis: new Date().toISOString() };
        }
        // Í∞Å Î©îÌä∏Î¶≠Ïóê ÎåÄÌï¥ Ïù¥ÏÉÅ ÌÉêÏßÄ ÏàòÌñâ
        const metricsToCheck = ['avgResponseTime', 'errorRate', 'requestRate'];
        for (const metric of metricsToCheck) {
            const values = history.slice(-100).map(h => h.metrics[metric] || 0);
            const current = currentMetrics[metric] || 0;
            // Z-Score Î∞©Î≤ï
            const mean = ss.mean(values);
            const std = ss.standardDeviation(values);
            const zScore = Math.abs((current - mean) / std);
            if (zScore > this.ANOMALY_Z_SCORE_THRESHOLD) {
                anomalies.push({
                    timestamp: new Date().toISOString(),
                    metric,
                    value: current,
                    expected: mean,
                    severity: Math.min(1, zScore / 4),
                    description: `${metric} is ${zScore.toFixed(1)} standard deviations from mean`
                });
            }
            // IQR Î∞©Î≤ï (Interquartile Range)
            const q1 = ss.quantile(values, 0.25);
            const q3 = ss.quantile(values, 0.75);
            const iqr = q3 - q1;
            const lowerBound = q1 - 1.5 * iqr;
            const upperBound = q3 + 1.5 * iqr;
            if (current < lowerBound || current > upperBound) {
                anomalies.push({
                    timestamp: new Date().toISOString(),
                    metric: `${metric}_iqr`,
                    value: current,
                    expected: (q1 + q3) / 2,
                    severity: 0.7,
                    description: `${metric} outside IQR bounds [${lowerBound.toFixed(1)}, ${upperBound.toFixed(1)}]`
                });
            }
        }
        // Î≥µÌï© Ïù¥ÏÉÅ ÌÉêÏßÄ (Ïó¨Îü¨ Î©îÌä∏Î¶≠Ïùò Ï°∞Ìï©)
        if (currentMetrics.avgResponseTime > 1000 && currentMetrics.errorRate > 0.1) {
            anomalies.push({
                timestamp: new Date().toISOString(),
                metric: 'compound',
                value: currentMetrics.avgResponseTime,
                expected: 300,
                severity: 0.9,
                description: 'High response time combined with high error rate'
            });
        }
        return {
            serviceId,
            anomalies: anomalies.slice(0, 5), // ÏµúÎåÄ 5Í∞ú Î∞òÌôò
            lastAnalysis: new Date().toISOString()
        };
    }
    analyzeTrends(serviceId) {
        const history = this.historicalData.get(serviceId) || [];
        if (history.length < 10) {
            return {
                performanceTrend: 'stable',
                usageTrend: 'stable',
                errorTrend: 'stable'
            };
        }
        const recentData = history.slice(-50);
        // Í∞Å Î©îÌä∏Î¶≠Ïùò Ï∂îÏÑ∏ Î∂ÑÏÑù
        const performanceTrend = this.calculateTrend(recentData.map(h => h.metrics.avgResponseTime || 0));
        const usageTrend = this.calculateTrend(recentData.map(h => h.metrics.requestCount || 0));
        const errorTrend = this.calculateTrend(recentData.map(h => h.metrics.errorRate || 0));
        return {
            performanceTrend: performanceTrend.direction,
            usageTrend: usageTrend.direction,
            errorTrend: errorTrend.direction,
            details: {
                performance: performanceTrend,
                usage: usageTrend,
                error: errorTrend
            }
        };
    }
    calculateTrend(values) {
        if (values.length < 3) {
            return { direction: 'stable', slope: 0, confidence: 0 };
        }
        const x = Array.from({ length: values.length }, (_, i) => i);
        const regression = new ml_regression_1.default.SimpleLinearRegression(x, values);
        const slope = regression.slope;
        const r2 = regression.score(x, values);
        // Ï∂îÏÑ∏ Î∞©Ìñ• Í≤∞Ï†ï
        let direction;
        const avgValue = ss.mean(values);
        const slopePercentage = (slope / avgValue) * 100;
        if (Math.abs(slopePercentage) < 5) {
            direction = 'stable';
        }
        else if (slope > 0) {
            direction = 'up';
        }
        else {
            direction = 'down';
        }
        return {
            direction,
            slope: slope.toFixed(2),
            confidence: r2.toFixed(2),
            percentage: slopePercentage.toFixed(1) + '%'
        };
    }
    recognizePatterns(serviceId) {
        const history = this.historicalData.get(serviceId) || [];
        if (history.length < 168) { // ÏµúÏÜå 1Ï£ºÏùº Îç∞Ïù¥ÌÑ∞
            return this.generateDefaultPatterns();
        }
        // ÏãúÍ∞ÑÎåÄÎ≥Ñ Ìå®ÌÑ¥ Î∂ÑÏÑù
        const hourlyPattern = this.analyzeHourlyPattern(history);
        const weeklyPattern = this.analyzeWeeklyPattern(history);
        const seasonality = this.detectSeasonality(history.map(h => h.metrics.avgResponseTime || 0));
        return {
            peakHours: hourlyPattern.peakHours,
            weeklyPattern: weeklyPattern.pattern,
            seasonality: seasonality.description,
            details: {
                hourly: hourlyPattern,
                weekly: weeklyPattern,
                seasonal: seasonality
            }
        };
    }
    analyzeHourlyPattern(history) {
        const hourlyData = new Map();
        // ÏãúÍ∞ÑÎåÄÎ≥ÑÎ°ú Îç∞Ïù¥ÌÑ∞ Í∑∏Î£πÌôî
        history.forEach(point => {
            const hour = new Date(point.timestamp).getHours();
            if (!hourlyData.has(hour)) {
                hourlyData.set(hour, []);
            }
            hourlyData.get(hour).push(point.metrics.avgResponseTime || 0);
        });
        // Í∞Å ÏãúÍ∞ÑÎåÄÏùò ÌèâÍ∑† Í≥ÑÏÇ∞
        const hourlyAverages = [];
        hourlyData.forEach((values, hour) => {
            hourlyAverages.push({ hour, avg: ss.mean(values) });
        });
        // Ï†ïÎ†¨ÌïòÏó¨ ÌîºÌÅ¨ ÏãúÍ∞Ñ Ï∞æÍ∏∞
        hourlyAverages.sort((a, b) => b.avg - a.avg);
        const peakHours = hourlyAverages.slice(0, 3).map(h => {
            const start = h.hour;
            const end = (h.hour + 1) % 24;
            return `${start.toString().padStart(2, '0')}:00-${end.toString().padStart(2, '0')}:00`;
        });
        return {
            peakHours,
            averages: hourlyAverages
        };
    }
    analyzeWeeklyPattern(history) {
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const weeklyData = new Map();
        // ÏöîÏùºÎ≥ÑÎ°ú Îç∞Ïù¥ÌÑ∞ Í∑∏Î£πÌôî
        history.forEach(point => {
            const dayName = weekdays[new Date(point.timestamp).getDay()];
            if (!weeklyData.has(dayName)) {
                weeklyData.set(dayName, []);
            }
            weeklyData.get(dayName).push(point.metrics.avgResponseTime || 0);
        });
        // Í∞Å ÏöîÏùºÏùò ÌèâÍ∑† Í≥ÑÏÇ∞
        const pattern = {};
        weekdays.forEach(day => {
            const values = weeklyData.get(day) || [];
            pattern[day] = values.length > 0 ? Math.round(ss.mean(values)) : 0;
        });
        return { pattern };
    }
    detectSeasonality(values) {
        if (values.length < 24) {
            return {
                nextValue: values[values.length - 1] || 0,
                description: 'Insufficient data for seasonality detection'
            };
        }
        // ÏûêÍ∏∞ÏÉÅÍ¥Ä Ìï®Ïàò (ACF) Í≥ÑÏÇ∞
        const acf = this.calculateACF(values, Math.min(50, Math.floor(values.length / 4)));
        // Ï£ºÏöî Ï£ºÍ∏∞ Ï∞æÍ∏∞
        const significantLags = [];
        const threshold = 2 / Math.sqrt(values.length); // 95% Ïã†Î¢∞Íµ¨Í∞Ñ
        for (let lag = 1; lag < acf.length; lag++) {
            if (Math.abs(acf[lag]) > threshold) {
                significantLags.push(lag);
            }
        }
        // Í≥ÑÏ†àÏÑ± ÏÑ§Î™Ö ÏÉùÏÑ±
        let description = 'No significant seasonality detected';
        if (significantLags.includes(24) || significantLags.includes(23) || significantLags.includes(25)) {
            description = 'Daily seasonality detected (24-hour cycle)';
        }
        else if (significantLags.includes(168) || significantLags.includes(167) || significantLags.includes(169)) {
            description = 'Weekly seasonality detected (7-day cycle)';
        }
        else if (significantLags.length > 0) {
            description = `Seasonality detected at lag ${significantLags[0]}`;
        }
        return {
            nextValue: values[values.length - 1],
            description,
            lags: significantLags,
            acf: acf.slice(0, 10)
        };
    }
    calculateACF(values, maxLag) {
        const mean = ss.mean(values);
        const variance = ss.variance(values);
        const acf = [1]; // ACF at lag 0 is always 1
        for (let lag = 1; lag <= maxLag; lag++) {
            let sum = 0;
            for (let i = lag; i < values.length; i++) {
                sum += (values[i] - mean) * (values[i - lag] - mean);
            }
            acf.push(sum / ((values.length - lag) * variance));
        }
        return acf;
    }
    // ============================================================================
    // Ìó¨Ìçº Î©îÏÑúÎìú
    // ============================================================================
    addToHistory(serviceId, metrics) {
        if (!this.historicalData.has(serviceId)) {
            this.historicalData.set(serviceId, []);
        }
        const history = this.historicalData.get(serviceId);
        history.push({
            timestamp: new Date().toISOString(),
            metrics
        });
        // ÌûàÏä§ÌÜ†Î¶¨ ÌÅ¨Í∏∞ Ï†úÌïú
        if (history.length > this.MAX_HISTORY_SIZE) {
            history.shift();
        }
    }
    normalizeData(values) {
        const min = Math.min(...values);
        const max = Math.max(...values);
        const range = max - min || 1;
        return values.map(v => (v - min) / range);
    }
    denormalizeValue(normalized, min, max) {
        return normalized * (max - min) + min;
    }
    calculateMAPE(actual, predicted) {
        if (actual.length !== predicted.length || actual.length === 0)
            return 100;
        let sum = 0;
        let count = 0;
        for (let i = 0; i < actual.length; i++) {
            if (actual[i] !== 0) {
                sum += Math.abs((actual[i] - predicted[i]) / actual[i]);
                count++;
            }
        }
        return count > 0 ? (sum / count) * 100 : 100;
    }
    generateIntelligentRecommendations(serviceId, forecast, history) {
        const recommendations = [];
        const current = history[history.length - 1]?.metrics || {};
        // Î∂ÄÌïò Í∏∞Î∞ò Í∂åÏû•ÏÇ¨Ìï≠
        if (forecast.nextHourLoad > 80) {
            recommendations.push('üî¥ High load expected: Consider scaling up resources');
            recommendations.push('üíæ Enable aggressive caching to reduce load');
            recommendations.push('üîÑ Implement request rate limiting');
        }
        else if (forecast.nextHourLoad < 20) {
            recommendations.push('üü¢ Low load expected: Consider scaling down to save costs');
            recommendations.push('üîß Good time for maintenance or updates');
        }
        // Ïù¥ÏÉÅ ÌÉêÏßÄ Í∏∞Î∞ò Í∂åÏû•ÏÇ¨Ìï≠
        if (forecast.anomalyProbability > 0.7) {
            recommendations.push('‚ö†Ô∏è High anomaly probability: Monitor closely');
            recommendations.push('üìä Check recent deployments or configuration changes');
        }
        // Ï∂îÏÑ∏ Í∏∞Î∞ò Í∂åÏû•ÏÇ¨Ìï≠
        const trends = this.analyzeTrends(serviceId);
        if (trends.performanceTrend === 'down' && trends.details?.performance?.confidence > 0.7) {
            recommendations.push('üìâ Performance degrading: Investigate root cause');
            recommendations.push('üîç Review recent code changes and dependencies');
        }
        // Ïò§Î•òÏú® Í∏∞Î∞ò Í∂åÏû•ÏÇ¨Ìï≠
        if (current.errorRate > 0.05) {
            recommendations.push('‚ùå High error rate detected: Review error logs');
            recommendations.push('üõ°Ô∏è Implement circuit breaker pattern');
        }
        // ÏùëÎãµÏãúÍ∞Ñ Í∏∞Î∞ò Í∂åÏû•ÏÇ¨Ìï≠
        if (current.avgResponseTime > 1000) {
            recommendations.push('üêå Slow response times: Optimize database queries');
            recommendations.push('‚ö° Consider implementing response caching');
        }
        return recommendations.length > 0 ? recommendations : ['‚úÖ Service operating normally'];
    }
    generateStatisticalRecommendations(prediction, mean, std) {
        const recommendations = [];
        if (prediction > mean + 2 * std) {
            recommendations.push('üìà Significant increase expected');
            recommendations.push('üîÑ Prepare for higher load');
        }
        else if (prediction < mean - 2 * std) {
            recommendations.push('üìâ Significant decrease expected');
            recommendations.push('üí∞ Opportunity to reduce resources');
        }
        else {
            recommendations.push('üìä Normal operating range expected');
        }
        return recommendations;
    }
    generateDefaultPatterns() {
        return {
            peakHours: ['09:00-11:00', '14:00-16:00'],
            weeklyPattern: {
                'Monday': 85,
                'Tuesday': 90,
                'Wednesday': 95,
                'Thursday': 88,
                'Friday': 80,
                'Saturday': 45,
                'Sunday': 40
            },
            seasonality: 'Insufficient data for pattern recognition'
        };
    }
    // ============================================================================
    // Ïä§ÏºàÎ†àÌÜ§ Î©îÏÑúÎìú (Ìè¥Î∞±Ïö©)
    // ============================================================================
    generateSkeletonPrediction(serviceId) {
        const mockLoad = Math.random() * 100;
        return {
            serviceId,
            predictions: {
                nextHourLoad: mockLoad,
                anomalyProbability: Math.random() * 0.3,
                recommendedActions: this.generateMockRecommendations(mockLoad),
                confidence: 0.85
            },
            trends: {
                performanceTrend: mockLoad > 70 ? 'down' : mockLoad < 30 ? 'up' : 'stable',
                usageTrend: Math.random() > 0.5 ? 'up' : 'stable',
                errorTrend: Math.random() > 0.8 ? 'up' : 'stable'
            },
            patterns: this.generateDefaultPatterns()
        };
    }
    generateMockRecommendations(load) {
        const recommendations = [];
        if (load > 80) {
            recommendations.push('Consider scaling up resources');
            recommendations.push('Enable caching for frequently accessed data');
        }
        else if (load < 20) {
            recommendations.push('Consider scaling down to reduce costs');
        }
        else {
            recommendations.push('Current configuration appears optimal');
        }
        return recommendations;
    }
    // ============================================================================
    // Î™®Îç∏ Í¥ÄÎ¶¨ Î©îÏÑúÎìú
    // ============================================================================
    async trainModel(serviceId) {
        if (!this.predictiveConfig.enabled) {
            logger_1.logger.warn('[PHASE-2] Model training not available - Phase 2 disabled');
            return false;
        }
        try {
            const history = this.historicalData.get(serviceId) || [];
            if (history.length < 100) {
                logger_1.logger.warn(`Insufficient data for training model: ${serviceId}`);
                return false;
            }
            // LSTM Î™®Îç∏ ÏÉùÏÑ± Î∞è ÌïôÏäµ
            if (!this.models.has(serviceId)) {
                await this.createLSTMModel(serviceId);
            }
            const model = this.models.get(serviceId);
            const trainingData = this.prepareTrainingData(history);
            await model.fit(trainingData.X, trainingData.y, {
                epochs: 50,
                batchSize: 32,
                validationSplit: 0.2,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        if (epoch % 10 === 0) {
                            logger_1.logger.info(`Training ${serviceId} - Epoch ${epoch}: loss=${logs?.loss?.toFixed(4)}`);
                        }
                    }
                }
            });
            // Ï†ïÎ¶¨
            trainingData.X.dispose();
            trainingData.y.dispose();
            logger_1.logger.info(`‚úÖ Model training completed for ${serviceId}`);
            return true;
        }
        catch (error) {
            logger_1.logger.error(`Model training failed for ${serviceId}:`, error);
            return false;
        }
    }
    prepareTrainingData(history) {
        const values = history.map(h => h.metrics.avgResponseTime || 0);
        const normalized = this.normalizeData(values);
        const windowSize = 10;
        const X = [];
        const y = [];
        for (let i = 0; i < normalized.length - windowSize - 1; i++) {
            X.push(normalized.slice(i, i + windowSize).map(v => [v]));
            y.push(normalized[i + windowSize]);
        }
        return {
            X: tf.tensor3d(X, [X.length, windowSize, 1]),
            y: tf.tensor2d(y, [y.length, 1])
        };
    }
    updateModelParameters(serviceId, parameters) {
        if (!this.predictiveConfig.enabled) {
            logger_1.logger.warn('[PHASE-2] Model parameter update not available - Phase 2 disabled');
            return false;
        }
        try {
            // Î™®Îç∏ ÌååÎùºÎØ∏ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ Î°úÏßÅ
            if (parameters.learningRate) {
                const model = this.models.get(serviceId);
                if (model) {
                    model.compile({
                        optimizer: tf.train.adam(parameters.learningRate),
                        loss: 'meanSquaredError',
                        metrics: ['mae']
                    });
                    logger_1.logger.info(`Updated learning rate for ${serviceId}: ${parameters.learningRate}`);
                }
            }
            if (parameters.anomalyThreshold) {
                this.ANOMALY_Z_SCORE_THRESHOLD = parameters.anomalyThreshold;
                logger_1.logger.info(`Updated anomaly threshold: ${parameters.anomalyThreshold}`);
            }
            return true;
        }
        catch (error) {
            logger_1.logger.error(`Failed to update model parameters for ${serviceId}:`, error);
            return false;
        }
    }
    // ============================================================================
    // ÏÉùÎ™ÖÏ£ºÍ∏∞ Î©îÏÑúÎìú
    // ============================================================================
    start() {
        if (this.predictiveConfig.enabled) {
            logger_1.logger.info('üöÄ PredictiveAnalyzer started with ML capabilities');
        }
        else {
            logger_1.logger.info('üîß PredictiveAnalyzer in skeleton mode');
        }
    }
    stop() {
        // Î™®Îì† Î™®Îç∏ Ï†ïÎ¶¨
        this.models.forEach((model, serviceId) => {
            model.dispose();
            logger_1.logger.info(`Model disposed for ${serviceId}`);
        });
        this.models.clear();
        // ÌûàÏä§ÌÜ†Î¶¨ Ï†ïÎ¶¨
        this.historicalData.clear();
        logger_1.logger.info('üõë PredictiveAnalyzer stopped');
    }
}
exports.PredictiveAnalyzer = PredictiveAnalyzer;
//# sourceMappingURL=PredictiveAnalyzer.js.map